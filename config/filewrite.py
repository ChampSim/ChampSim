#    Copyright 2023 The ChampSim Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import difflib
import hashlib
import itertools
import functools
import operator
import os
import json

from .makefile import get_makefile_lines
from .instantiation_file import get_instantiation_lines
from .constants_file import get_constants_file
from . import modules
from . import util

makefile_file_name = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '_configuration.mk')

warning_text = (
'THIS FILE IS AUTOMATICALLY GENERATED',
'Do not edit this file. It will be overwritten when the configure script is run.',
)

def contextualize_warning(prefix, line_prefix, suffix):
    return (prefix, *(f' {line_prefix} {l}' for l in warning_text), suffix, '')

def cxx_generated_warning():
    return contextualize_warning('/***', '*', '***/')

def make_generated_warning():
    return contextualize_warning('###', '#', '###')

def files_are_different(rfp, new_rfp, verbose=False):
    ''' Determine if the two files are different, excluding whitespace at the beginning or end of lines '''
    old_file_lines = list(l.strip() for l in rfp)
    new_file_lines = list(l.strip() for l in new_rfp)
    diff = difflib.SequenceMatcher(a=old_file_lines, b=new_file_lines).ratio()
    if verbose:
        print('File difference:', diff)
    return diff < 1

def write_if_different(fname, new_file_string, file=None, verbose=False):
    '''
    Write to a file if and only if it differs from an existing file with the same name.

    :param fname: the name of the destination file
    :param new_file_string: the desired contents of the file
    '''
    should_write = True
    if os.path.exists(fname):
        with open(fname, 'rt') as rfp:
            should_write = files_are_different(rfp, new_file_string.splitlines())

    if should_write:
        if verbose:
            print("Writing file", fname)

        if file is None:
            os.makedirs(os.path.abspath(os.path.dirname(fname)), exist_ok=True)
            with open(fname, 'wt') as wfp:
                wfp.write(new_file_string)
        else:
            file.write(new_file_string)

def generate_legacy_module_information(containing_dir, module_info):
    ''' Generates all of the include-files with module information '''
    if any(module_info.values()):
        core_declarations, cache_declarations, module_definitions = modules.get_legacy_module_lines(
                module_info['branch'].values(),
                module_info['btb'].values(),
                module_info['pref'].values(),
                module_info['repl'].values()
            )

        yield os.path.join(containing_dir, 'ooo_cpu_module_decl.inc'), (*cxx_generated_warning(), *core_declarations)
        yield os.path.join(containing_dir, 'cache_module_decl.inc'), (*cxx_generated_warning(), *cache_declarations)
        yield os.path.join(containing_dir, 'module_def.inc'), (
                *cxx_generated_warning(),
                '#ifndef GENERATED_MODULES_INC', '#define GENERATED_MODULES_INC', '#include "modules.h"', 'namespace champsim::modules::generated','{',
                *module_definitions,
                '}','#endif'
            )

        joined_info_items = itertools.chain(*(v.items() for v in module_info.values()))
        for k,v in joined_info_items:
            fname = os.path.join(containing_dir, k+'.options')
            yield fname, modules.get_legacy_module_opts_lines(v)

def generate_build_information(inc_dir, config_flags):
    ''' Generates all of the build-level include-files module '''
    fname = os.path.join(inc_dir, 'config.options')
    champsim_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

    global_inc_dir = os.path.join(champsim_root, 'inc')

    vcpkg_dir = os.path.join(champsim_root, 'vcpkg_installed')
    vcpkg_triplet = next(filter(lambda triplet: triplet != 'vcpkg', os.listdir(vcpkg_dir)), None)
    vcpkg_inc_dir = os.path.join(vcpkg_dir, vcpkg_triplet, 'include')

    yield fname, itertools.chain((f'-I{inc_dir}',f'-I{global_inc_dir}',f'-isystem {vcpkg_inc_dir}'), config_flags)

def try_int(val):
    try:
      return int(val)
    except:
      raise TypeError

class Fragment:
    '''
    Examines the given config and prepares to write the needed files.

    Programs may use this class for fine-grained control of when and how files are written.

    :param parsed_config: the result of parsing a configuration file
    :param bindir_name: the directory in which to place the binaries
    :param srcdir_name: the directory to search for source files
    :param objdir_name: the directory to place object files
    '''
    @staticmethod
    def __part_joiner(iterable):
        it = iter(iterable)
        key, first_value = next(it)

        header_len = 0
        if os.path.splitext(key)[1] in ('.cc', '.h', '.inc'):
            header_len = len(cxx_generated_warning())
        if os.path.splitext(key)[1] in ('.mk',):
            header_len = len(make_generated_warning())

        contents_parts = (itertools.islice(v[1], header_len, None) for v in it)
        return key, tuple(itertools.chain(first_value, *contents_parts))

    @staticmethod
    def join(head_frags, *tail_frags):
        ''' Merge multiple Fragments into one. '''
        copy = head_frags
        joined_parts = list(itertools.chain(*(f.file_parts() for f in (head_frags, *tail_frags))))
        copy.fileparts = list(util.collect(joined_parts, operator.itemgetter(0), Fragment.__part_joiner))
        return copy

    def __init__(self, parsed_config, bindir_name, srcdir_names, objdir_name, omit_main=False, verbose=False):
        champsim_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        core_sources = os.path.join(champsim_root, 'src')

        build_id = hashlib.shake_128(json.dumps(parsed_config, default=try_int).encode('utf-8')).hexdigest(8)

        executable_basename, elements, modules_to_compile, module_info, config_file, env = parsed_config

        unique_obj_dir = os.path.join(objdir_name, build_id)
        inc_dir = os.path.join(unique_obj_dir, 'inc')

        legacy_module_info = { mod_type: { k:v for k,v in util.subdict(mod_set, modules_to_compile).items() if v.get('legacy') } for mod_type, mod_set in module_info.items() }
        joined_module_info = util.subdict(util.chain(*module_info.values()), modules_to_compile) # remove module type tag
        executable = os.path.join(bindir_name, executable_basename)
        if verbose:
            print('For Executable', executable)
            print('Writing objects to', unique_obj_dir)

        self.fileparts = [
            # Instantiation file
            (os.path.join(inc_dir, 'core_inst.inc'), (*cxx_generated_warning(), *get_instantiation_lines(**elements))),

            # Constants header
            (os.path.join(inc_dir, 'champsim_constants.h'), (*cxx_generated_warning(), *get_constants_file(config_file, elements['pmem']))),

            # Module name mangling
            *generate_legacy_module_information(inc_dir, legacy_module_info),

            # Build-level compile flags
            *generate_build_information(inc_dir, util.subdict(env, ('CPPFLAGS', 'CXXFLAGS', 'LDFLAGS', 'LDLIBS')).values()),

            # Makefile generation
            (makefile_file_name, (
                *make_generated_warning(),
                *get_makefile_lines(unique_obj_dir, build_id, executable, (*srcdir_names, core_sources), joined_module_info, omit_main)
            ))
        ]
        self.fileparts = list(util.collect(self.fileparts, operator.itemgetter(0), Fragment.__part_joiner)) # hoist the parts

    def map_files(self, func):
        yield from itertools.starmap(func, self.fileparts)

    def write(self):
        for fname, fcontents in self.fileparts:
            write_if_different(fname, '\n'.join(fcontents))

    def file_parts(self):
        return self.fileparts

    def __iter__(self):
        return iter(self.file_parts())

class FileWriter:
    '''
    This class maintains the state of one or more configurations to be written

    This class provides a context manager interface over a set of Fragments, and is more convenient for general use.
    '''
    def __init__(self, bindir_name=None, objdir_name=None):
        '''
        param bindir_name: The default directory for binaries if none is given to write_files().
        param objdir_name: The default directory for object files if none is given to write_files().
        '''
        self.fragments = []
        self.bindir_name = bindir_name
        self.objdir_name = objdir_name

    def __enter__(self):
        self.fragments = []
        return self

    def write_files(self, parsed_config, bindir_name=None, srcdir_names=None, objdir_name=None, omit_main=False):
        ''' Apply defaults to get_file_lines() '''
        local_bindir_name = bindir_name or self.bindir_name
        local_srcdir_names = srcdir_names or []
        local_objdir_name = os.path.abspath(objdir_name or self.objdir_name)

        self.fragments.append(Fragment(parsed_config, local_bindir_name, local_srcdir_names, local_objdir_name, omit_main))

    @staticmethod
    def write_fragments(*fragments):
        ''' Write out a set of prepared fragments '''
        if not fragments:
            return
        joined_fragments = Fragment.join(*fragments)
        for fname, fcontents in joined_fragments.file_parts():
            write_if_different(fname, '\n'.join(fcontents))

    def finish(self):
        FileWriter.write_fragments(*self.fragments)

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            self.finish()
