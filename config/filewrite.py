#    Copyright 2023 The ChampSim Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import difflib
import hashlib
import itertools
import operator
import os
import json

from .makefile import get_makefile_lines
from .instantiation_file import get_instantiation_lines
from .constants_file import get_constants_file
from . import modules
from . import util

makefile_file_name = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '_configuration.mk')

warning_text = (
'THIS FILE IS AUTOMATICALLY GENERATED',
'Do not edit this file. It will be overwritten when the configure script is run.',
)

def contextualize_warning(prefix, line_prefix, suffix):
    return (prefix, *(f' {line_prefix} {l}' for l in warning_text), suffix, '')

def cxx_generated_warning():
    return contextualize_warning('/***', '*', '***/')

def make_generated_warning():
    return contextualize_warning('###', '#', '###')

def files_are_different(rfp, new_rfp, verbose=False):
    ''' Determine if the two files are different, excluding whitespace at the beginning or end of lines '''
    old_file_lines = list(l.strip() for l in rfp)
    new_file_lines = list(l.strip() for l in new_rfp)
    diff = difflib.SequenceMatcher(a=old_file_lines, b=new_file_lines).ratio()
    if verbose:
        print('File difference:', diff)
    return diff < 1

def write_if_different(fname, new_file_string, file=None, verbose=False):
    '''
    Write to a file if and only if it differs from an existing file with the same name.

    :param fname: the name of the destination file
    :param new_file_string: the desired contents of the file
    '''
    should_write = True
    if os.path.exists(fname):
        with open(fname, 'rt') as rfp:
            should_write = files_are_different(rfp, new_file_string.splitlines())

    if should_write:
        if verbose:
            print("Writing file", fname)

        if file is None:
            os.makedirs(os.path.abspath(os.path.dirname(fname)), exist_ok=True)
            with open(fname, 'wt') as wfp:
                wfp.write(new_file_string)
        else:
            file.write(new_file_string)

def generate_legacy_module_information(containing_dir, module_info):
    ''' Generates all of the include-files with module information '''
    if any(module_info.values()):
        core_declarations, cache_declarations, module_definitions = modules.get_legacy_module_lines(
                module_info['branch'].values(),
                module_info['btb'].values(),
                module_info['pref'].values(),
                module_info['repl'].values()
            )

        yield os.path.join(containing_dir, 'ooo_cpu_module_decl.inc'), (*cxx_generated_warning(), *core_declarations)
        yield os.path.join(containing_dir, 'cache_module_decl.inc'), (*cxx_generated_warning(), *cache_declarations)
        yield os.path.join(containing_dir, 'module_def.inc'), (
                *cxx_generated_warning(),
                '#ifndef GENERATED_MODULES_INC',
                '#define GENERATED_MODULES_INC',
                '#include "modules.h"',
                'namespace champsim::modules::generated',
                '{',
                *module_definitions,
                '}',
                '#endif'
            )

        joined_info_items = itertools.chain(*(v.items() for v in module_info.values()))
        for k,v in joined_info_items:
            fname = os.path.join(containing_dir, k+'.options')
            yield fname, modules.get_legacy_module_opts_lines(v)

def try_int(val):
    try:
        return int(val)
    except Exception as exc:
        raise TypeError from exc

class Fragment:
    '''
    Examines the given config and prepares to write the needed files.

    Programs may use this class for fine-grained control of when and how files are written.

    :param parsed_config: the result of parsing a configuration file
    :param bindir_name: the directory in which to place the binaries
    :param srcdir_name: the directory to search for source files
    :param objdir_name: the directory to place object files
    '''
    @staticmethod
    def __part_joiner(iterable):
        it = iter(iterable)
        key, first_value = next(it)

        header_len = 0
        if os.path.splitext(key)[1] in ('.cc', '.h', '.inc'):
            header_len = len(cxx_generated_warning())
        if os.path.splitext(key)[1] in ('.mk',):
            header_len = len(make_generated_warning())

        contents_parts = (itertools.islice(v[1], header_len, None) for v in it)
        return key, tuple(itertools.chain(first_value, *contents_parts))

    def __init__(self, fileparts=None):
        self.fileparts = list(fileparts or [])

    @staticmethod
    def join(*frags):
        ''' Merge multiple Fragments into one. '''
        joined_parts = list(itertools.chain(*(f.file_parts() for f in frags)))
        fileparts = list(util.collect(joined_parts, operator.itemgetter(0), Fragment.__part_joiner))
        return Fragment(fileparts)

    @staticmethod
    def from_config(parsed_config, bindir_name, srcdir_names, objdir_name, omit_main=False, verbose=False):
        champsim_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        core_sources = os.path.join(champsim_root, 'src')

        build_id = hashlib.shake_128(json.dumps(parsed_config, sort_keys=True, default=try_int).encode('utf-8')).hexdigest(8)

        executable_basename, elements, modules_to_compile, module_info, config_file = parsed_config

        unique_obj_dir = os.path.join(objdir_name, build_id)
        inc_dir = os.path.join(unique_obj_dir, 'inc')

        legacy_module_info = {
            mod_type: {
                k:v for k,v in util.subdict(mod_set, modules_to_compile).items() if v.get('legacy')
            } for mod_type, mod_set in module_info.items()
        }
        joined_module_info = util.subdict(util.chain(*module_info.values()), modules_to_compile) # remove module type tag
        executable = os.path.join(bindir_name, executable_basename)
        if verbose:
            print('For Executable', executable)
            if any(legacy_module_info.values()):
                print('Legacy modules detected:')
                for module in itertools.chain.from_iterable(v.values() for v in legacy_module_info.values()):
                    print(f'  {module["name"]}: {module["path"]} -> {module["class"]}')
            print('Modules:')
            for module in joined_module_info.values():
                print(f'  {module["name"]}: {module["path"]} -> {module["class"]}')
            print('Writing objects to', unique_obj_dir)

        fileparts = [
            # Instantiation file
            (os.path.join(inc_dir, 'core_inst.inc'), (*cxx_generated_warning(), *get_instantiation_lines(**elements))),

            # Constants header
            (os.path.join(inc_dir, 'champsim_constants.h'), (*cxx_generated_warning(), *get_constants_file(config_file, elements['pmem']))),

            # Module name mangling
            *generate_legacy_module_information(inc_dir, legacy_module_info),

            # Makefile generation
            (makefile_file_name, (
                *make_generated_warning(),
                *get_makefile_lines(unique_obj_dir, build_id, executable, (*srcdir_names, core_sources), joined_module_info, omit_main)
            ))
        ]
        return Fragment(list(util.collect(fileparts, operator.itemgetter(0), Fragment.__part_joiner))) # hoist the parts

    def write(self):
        for fname, fcontents in self.fileparts:
            write_if_different(fname, '\n'.join(fcontents))

    def file_parts(self):
        return self.fileparts

    def __iter__(self):
        return iter(self.file_parts())

class FileWriter:
    '''
    This class maintains the state of one or more configurations to be written

    This class provides a context manager interface over a set of Fragments, and is more convenient for general use.
    '''
    def __init__(self, bindir_name=None, objdir_name=None, verbose=False):
        '''
        param bindir_name: The default directory for binaries if none is given to write_files().
        param objdir_name: The default directory for object files if none is given to write_files().
        '''
        self.fragments = []
        self.bindir_name = bindir_name
        self.objdir_name = objdir_name
        self.verbose = verbose

    def __enter__(self):
        self.fragments = []
        return self

    def write_files(self, parsed_config, bindir_name=None, srcdir_names=None, objdir_name=None, omit_main=False):
        ''' Apply defaults to get_file_lines() '''
        local_bindir_name = bindir_name or self.bindir_name
        local_srcdir_names = srcdir_names or []
        local_objdir_name = os.path.abspath(objdir_name or self.objdir_name)

        self.fragments.append(Fragment.from_config(parsed_config, local_bindir_name, local_srcdir_names, local_objdir_name, omit_main, verbose=self.verbose))

    @staticmethod
    def write_fragments(*fragments):
        ''' Write out a set of prepared fragments '''
        if not fragments:
            return
        Fragment.join(*fragments).write()

    def finish(self):
        FileWriter.write_fragments(*self.fragments)

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            self.finish()
